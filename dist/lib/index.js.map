{"version":3,"file":"index.js","mappings":"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","sources":["webpack://simple-data-provider/webpack/universalModuleDefinition","webpack://simple-data-provider/./lib/index.ts","webpack://simple-data-provider/./lib/internal-types.ts","webpack://simple-data-provider/./lib/retrieve.ts","webpack://simple-data-provider/./lib/values.ts","webpack://simple-data-provider/webpack/bootstrap","webpack://simple-data-provider/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"simple-data-provider\"] = factory();\n\telse\n\t\troot[\"simple-data-provider\"] = factory();\n})(self, function() {\nreturn ","export * from \"./types\";\nexport * from \"./values\";\nexport * from \"./retrieve\";\n","import { DataProvider } from \"./types\";\n\nexport enum ProviderType {\n  LIST,\n  METHOD,\n  METHOD_SYNC,\n  METHOD_ASYNC,\n  GENERATOR,\n  GENERATOR_ASYNC,\n  ITERATOR,\n  ITERATOR_ASYNC,\n  OBJECT,\n  PRIMITIVE,\n  SET,\n  UNKNOWN\n}\n\n/**\n * The state stored for iterating through a provider.\n */\nexport type IterState = {\n  type: ProviderType;\n};\n\n/**\n * The data provider type after it has been exposed to the iterating concept.\n */\nexport type DataProviderInternal<T> = DataProvider<T> & {\n  __iter__: { [key: string]: IterState };\n};\n\n/**\n * Typeguard for simple iterator types\n */\nexport function isIterable<T>(val: any): val is IterableIterator<T> {\n  if (!val) return false;\n  return typeof val[Symbol.iterator] === \"function\";\n}\n\n/**\n * Typeguard for async iterator types\n */\nexport function isAsyncIterable<T>(val: any): val is AsyncIterableIterator<T> {\n  if (!val) return false;\n  return typeof val[Symbol.asyncIterator] === \"function\";\n}\n","/**\n * Wrapper in the event you don't want to write out the for await loop (this causes overhead).\n *\n * This is also available to help environments that may not be able to transpile or handle the for await syntax.\n */\nexport async function retrieve<T>(\n  values: AsyncGenerator<T, void, undefined>,\n  access: (val: T) => void\n) {\n  for await (const val of values) {\n    access(val);\n  }\n}\n","import {\n  isAsyncIterable,\n  isIterable,\n  IterState,\n  ProviderType\n} from \"./internal-types\";\nimport {\n  DataProvider,\n  ExitValue,\n  IterableProvider,\n  MethodProvider,\n  ObjectProvider,\n  SetProvider\n} from \"./types\";\n\n/**\n * Typeguard to see if the provider is a simple list.\n */\nfunction isListProvider<T>(provider: DataProvider<T>): provider is T[] {\n  return Array.isArray(provider);\n}\n\n/**\n * This determines if the provider is a method.\n */\nfunction isMethodProvider<T>(\n  provider: DataProvider<T>\n): provider is MethodProvider<T> {\n  return typeof provider === \"function\";\n}\n\n/**\n * This determines if the provider is a Set type (one that provides a .values() Iterable)\n */\nfunction isSetProvider<T>(\n  provider: DataProvider<T>\n): provider is SetProvider<T> {\n  return (\n    (provider as any).constructor !== undefined &&\n    ((provider as any).constructor === Set ||\n      (provider as any).constructor === Map)\n  );\n}\n\n/**\n * This determines if the provider is an iterable provider.\n */\nfunction isIterableProvider<T>(\n  provider: DataProvider<T>\n): provider is IterableProvider<T> {\n  return typeof (provider as any)[Symbol.iterator] === \"function\";\n}\n\n/**\n * This determines if the provider is an async iterable provider.\n */\nfunction isAsyncIterableProvider<T>(\n  provider: DataProvider<T>\n): provider is IterableProvider<T> {\n  return typeof (provider as any)[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * This ensures (after many other checks) that this provider is a simple object that has values that can be returned.\n */\nfunction isObjectProvider<T>(\n  provider: DataProvider<T>\n): provider is ObjectProvider<T> {\n  return typeof provider === \"object\";\n}\n\n/**\n * Do an intial analysis of our provider type. Note that this does NOT figure out the official type of this provider.\n * The only way to get a robust understanding of the provider we, we have to analyze the return value of the method\n * being called once in order to truly know what the provider is providing from a method.\n */\nfunction getInitialProviderType<T>(provider: DataProvider<T>): ProviderType {\n  if (isListProvider(provider)) return ProviderType.LIST;\n  if (isSetProvider(provider)) return ProviderType.SET;\n  if (isIterableProvider(provider)) return ProviderType.ITERATOR;\n  if (isAsyncIterableProvider(provider)) return ProviderType.ITERATOR_ASYNC;\n  if (isObjectProvider(provider)) return ProviderType.OBJECT;\n  if (isMethodProvider(provider)) return ProviderType.METHOD;\n  return ProviderType.UNKNOWN;\n}\n\n/**\n * Provides the initial state of the iteration\n */\nfunction initState<T>(provider: DataProvider<T>): IterState {\n  const type = getInitialProviderType(provider);\n  return { type };\n}\n\n/**\n * This is a uniform accessor into a DataProvider type. It will always provide the next row of data if available.\n */\nexport async function* values<T>(\n  provider: DataProvider<T>\n): AsyncGenerator<T, void, ExitValue> {\n  const state = initState(provider);\n\n  // We can use a pre-analyzed type for the data provider to quickly provide the fastest way to get it's next value\n  switch (state.type) {\n    // If our provider is a list, then we simply loop through the list and return the found values.\n    case ProviderType.LIST: {\n      const list = provider as T[];\n\n      for (let i = 0, iMax = list.length; i < iMax; ++i) {\n        yield list[i];\n      }\n\n      return void 0;\n    }\n\n    // If our provider is an iterator, then we just iterate it to completion\n    case ProviderType.ITERATOR: {\n      const iter = provider as IterableIterator<T>;\n\n      if (iter.next) {\n        let result = iter.next();\n\n        while (!result.done) {\n          yield result.value;\n          result = iter.next();\n        }\n      } else {\n        for (const result of iter) {\n          yield result;\n        }\n      }\n\n      return void 0;\n    }\n\n    // If our provider is an iterator, then we just iterate it to completion\n    case ProviderType.ITERATOR_ASYNC: {\n      const iter = provider as AsyncIterableIterator<T>;\n\n      for await (const result of iter) {\n        yield result;\n      }\n\n      return void 0;\n    }\n\n    // If our provider is a Set type (Map or Set), then we provide the values of the set\n    case ProviderType.SET: {\n      const iter = (provider as SetProvider<T>).values();\n      let result = iter.next();\n\n      while (!result.done) {\n        yield result.value;\n        result = iter.next();\n      }\n\n      return void 0;\n    }\n\n    // If our provider is an Object type, then we provide the values found in the object\n    case ProviderType.OBJECT: {\n      const obj = provider as ObjectProvider<T>;\n      const values = Object.values(obj);\n\n      for (let i = 0, iMax = values.length; i < iMax; ++i) {\n        yield values[i];\n      }\n\n      return void 0;\n    }\n\n    // If we have determined the provider is a method, we must analyze the result of the method to determine what type\n    // of method it is\n    case ProviderType.METHOD: {\n      const method = provider as Function;\n      let checkValue = method(0);\n\n      if (checkValue === void 0) return void 0;\n      else if (isIterable<T>(checkValue)) state.type = ProviderType.GENERATOR;\n      else if (isAsyncIterable<T>(checkValue)) {\n        state.type = ProviderType.GENERATOR_ASYNC;\n      } else if (checkValue instanceof Promise) {\n        state.type = ProviderType.METHOD_ASYNC;\n        yield await checkValue;\n      } else {\n        state.type = ProviderType.METHOD_SYNC;\n        yield checkValue;\n      }\n\n      switch (state.type) {\n        // Method is determined to be a generator\n        case ProviderType.GENERATOR: {\n          const iter = checkValue as Generator<T, T | void, number>;\n          let index = -1;\n          let result = iter.next(++index);\n\n          while (!result.done) {\n            yield result.value;\n            result = iter.next(++index);\n          }\n\n          return void 0;\n        }\n\n        // Method is determined to be an async generator\n        case ProviderType.GENERATOR_ASYNC: {\n          const iter = checkValue as AsyncGenerator<T, T | void, number>;\n          let index = -1;\n          let result = await iter.next(++index);\n\n          while (!result.done) {\n            yield result.value;\n            result = await iter.next(++index);\n          }\n\n          return void 0;\n        }\n\n        // Method is an async method\n        case ProviderType.METHOD_ASYNC: {\n          let i = 0;\n\n          while (checkValue !== void 0) {\n            checkValue = await method(++i);\n            if (checkValue === void 0) return void 0;\n            yield checkValue;\n          }\n\n          return void 0;\n        }\n\n        // Method is just a simple method\n        case ProviderType.METHOD_SYNC: {\n          let i = 0;\n\n          while (checkValue !== void 0) {\n            checkValue = method(++i);\n            if (checkValue === void 0) return void 0;\n            yield checkValue;\n          }\n\n          return void 0;\n        }\n\n        default: {\n          console.warn(\n            \"The provider could not have it's type determined for iteration. Thus no values will be returned.\"\n          );\n          return void 0;\n        }\n      }\n    }\n\n    // An unknown type will return itself.\n    case ProviderType.UNKNOWN: {\n      yield (provider as unknown) as T;\n      return void 0;\n    }\n\n    // We can not have determined if the method was a specific method type yet. If we actually hit this, then we have\n    // found a bug.\n    case ProviderType.METHOD_SYNC:\n    case ProviderType.METHOD_ASYNC:\n    case ProviderType.GENERATOR:\n    case ProviderType.GENERATOR_ASYNC:\n      console.warn(\n        \"Undefined behavior occurred while processing a provider. No values will be returned.\"\n      );\n      return void 0;\n\n    default:\n      console.warn(\n        \"The provider could not have it's type properly determined for iteration. Thus no values will be returned.\"\n      );\n      return void 0;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(321);\n"],"names":["root","factory","exports","module","define","amd","self","__exportStar","ProviderType","val","Symbol","iterator","asyncIterator","values","access","values_1","getInitialProviderType","provider","Array","isArray","isListProvider","internal_types_1","LIST","undefined","constructor","Set","Map","isSetProvider","SET","isIterableProvider","ITERATOR","isAsyncIterableProvider","ITERATOR_ASYNC","isObjectProvider","OBJECT","isMethodProvider","METHOD","UNKNOWN","initState","type","state","METHOD_SYNC","METHOD_ASYNC","GENERATOR","GENERATOR_ASYNC","i","iMax","list","length","_e","iter","next","result","done","value","iter_1","iter_1_1","iter_2","obj","values_2","Object","checkValue","method","isIterable","isAsyncIterable","Promise","_b","index","console","warn","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}