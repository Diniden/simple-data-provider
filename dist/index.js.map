{"version":3,"sources":["webpack://simple-data-provider/webpack/universalModuleDefinition","webpack://simple-data-provider/webpack/bootstrap","webpack://simple-data-provider/./src/index.ts","webpack://simple-data-provider/./src/values.ts","webpack://simple-data-provider/./src/internal-types.ts","webpack://simple-data-provider/./src/retrieve.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"simple-data-provider\"] = factory();\n\telse\n\t\troot[\"simple-data-provider\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export * from \"./types\";\nexport * from \"./values\";\nexport * from \"./retrieve\";\n","import {\n  isAsyncIterable,\n  isIterable,\n  IterState,\n  ProviderType\n} from \"./internal-types\";\nimport {\n  DataProvider,\n  ExitValue,\n  IterableProvider,\n  MethodProvider,\n  ObjectProvider,\n  SetProvider\n} from \"./types\";\n\n/**\n * Typeguard to see if the provider is a simple list.\n */\nfunction isListProvider<T>(provider: DataProvider<T>): provider is T[] {\n  return Array.isArray(provider);\n}\n\n/**\n * This determines if the provider is a method.\n */\nfunction isMethodProvider<T>(\n  provider: DataProvider<T>\n): provider is MethodProvider<T> {\n  return typeof provider === \"function\";\n}\n\n/**\n * This determines if the provider is a Set type (one that provides a .values() Iterable)\n */\nfunction isSetProvider<T>(\n  provider: DataProvider<T>\n): provider is SetProvider<T> {\n  return (\n    (provider as any).constructor !== undefined &&\n    ((provider as any).constructor === Set ||\n      (provider as any).constructor === Map)\n  );\n}\n\n/**\n * This determines if the provider is an iterable provider.\n */\nfunction isIterableProvider<T>(\n  provider: DataProvider<T>\n): provider is IterableProvider<T> {\n  return typeof (provider as any)[Symbol.iterator] === \"function\";\n}\n\n/**\n * This determines if the provider is an async iterable provider.\n */\nfunction isAsyncIterableProvider<T>(\n  provider: DataProvider<T>\n): provider is IterableProvider<T> {\n  return typeof (provider as any)[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * This ensures (after many other checks) that this provider is a simple object that has values that can be returned.\n */\nfunction isObjectProvider<T>(\n  provider: DataProvider<T>\n): provider is ObjectProvider<T> {\n  return typeof provider === \"object\";\n}\n\n/**\n * Do an intial analysis of our provider type. Note that this does NOT figure out the official type of this provider.\n * The only way to get a robust understanding of the provider we, we have to analyze the return value of the method\n * being called once in order to truly know what the provider is providing from a method.\n */\nfunction getInitialProviderType<T>(provider: DataProvider<T>): ProviderType {\n  if (isListProvider(provider)) return ProviderType.LIST;\n  if (isSetProvider(provider)) return ProviderType.SET;\n  if (isIterableProvider(provider)) return ProviderType.ITERATOR;\n  if (isAsyncIterableProvider(provider)) return ProviderType.ITERATOR_ASYNC;\n  if (isObjectProvider(provider)) return ProviderType.OBJECT;\n  if (isMethodProvider(provider)) return ProviderType.METHOD;\n  return ProviderType.UNKNOWN;\n}\n\n/**\n * Provides the initial state of the iteration\n */\nfunction initState<T>(provider: DataProvider<T>): IterState {\n  const type = getInitialProviderType(provider);\n  return { type };\n}\n\n/**\n * This is a uniform accessor into a DataProvider type. It will always provide the next row of data if available.\n */\nexport async function* values<T>(\n  provider: DataProvider<T>\n): AsyncGenerator<T, void, ExitValue> {\n  const state = initState(provider);\n\n  // We can use a pre-analyzed type for the data provider to quickly provide the fastest way to get it's next value\n  switch (state.type) {\n    // If our provider is a list, then we simply loop through the list and return the found values.\n    case ProviderType.LIST: {\n      const list = provider as T[];\n\n      for (let i = 0, iMax = list.length; i < iMax; ++i) {\n        yield list[i];\n      }\n\n      return void 0;\n    }\n\n    // If our provider is an iterator, then we just iterate it to completion\n    case ProviderType.ITERATOR: {\n      const iter = provider as IterableIterator<T>;\n\n      if (iter.next) {\n        let result = iter.next();\n\n        while (!result.done) {\n          yield result.value;\n          result = iter.next();\n        }\n      } else {\n        for (const result of iter) {\n          yield result;\n        }\n      }\n\n      return void 0;\n    }\n\n    // If our provider is an iterator, then we just iterate it to completion\n    case ProviderType.ITERATOR_ASYNC: {\n      const iter = provider as AsyncIterableIterator<T>;\n\n      for await (const result of iter) {\n        yield result;\n      }\n\n      return void 0;\n    }\n\n    // If our provider is a Set type (Map or Set), then we provide the values of the set\n    case ProviderType.SET: {\n      const iter = (provider as SetProvider<T>).values();\n      let result = iter.next();\n\n      while (!result.done) {\n        yield result.value;\n        result = iter.next();\n      }\n\n      return void 0;\n    }\n\n    // If our provider is an Object type, then we provide the values found in the object\n    case ProviderType.OBJECT: {\n      const obj = provider as ObjectProvider<T>;\n      const values = Object.values(obj);\n\n      for (let i = 0, iMax = values.length; i < iMax; ++i) {\n        yield values[i];\n      }\n\n      return void 0;\n    }\n\n    // If we have determined the provider is a method, we must analyze the result of the method to determine what type\n    // of method it is\n    case ProviderType.METHOD: {\n      const method = provider as Function;\n      let checkValue = method(0);\n\n      if (checkValue === void 0) return void 0;\n      else if (isIterable<T>(checkValue)) state.type = ProviderType.GENERATOR;\n      else if (isAsyncIterable<T>(checkValue)) {\n        state.type = ProviderType.GENERATOR_ASYNC;\n      } else if (checkValue instanceof Promise) {\n        state.type = ProviderType.METHOD_ASYNC;\n        yield await checkValue;\n      } else {\n        state.type = ProviderType.METHOD_SYNC;\n        yield checkValue;\n      }\n\n      switch (state.type) {\n        // Method is determined to be a generator\n        case ProviderType.GENERATOR: {\n          const iter = checkValue as Generator<T, void, number>;\n          let index = -1;\n          let result = iter.next(++index);\n\n          while (!result.done) {\n            yield result.value;\n            result = iter.next(++index);\n          }\n\n          return void 0;\n        }\n\n        // Method is determined to be an async generator\n        case ProviderType.GENERATOR_ASYNC: {\n          const iter = checkValue as AsyncGenerator<T, void, number>;\n          let index = -1;\n          let result = await iter.next(++index);\n\n          while (!result.done) {\n            yield result.value;\n            result = await iter.next(++index);\n          }\n\n          return void 0;\n        }\n\n        // Method is an async method\n        case ProviderType.METHOD_ASYNC: {\n          let i = 0;\n\n          while (checkValue !== void 0) {\n            checkValue = await method(++i);\n            if (checkValue === void 0) return void 0;\n            yield checkValue;\n          }\n\n          return void 0;\n        }\n\n        // Method is just a simple method\n        case ProviderType.METHOD_SYNC: {\n          let i = 0;\n\n          while (checkValue !== void 0) {\n            checkValue = method(++i);\n            if (checkValue === void 0) return void 0;\n            yield checkValue;\n          }\n\n          return void 0;\n        }\n\n        default: {\n          console.warn(\n            \"The provider could not have it's type determined for iteration. Thus no values will be returned.\"\n          );\n          return void 0;\n        }\n      }\n    }\n\n    // An unknown type will return itself.\n    case ProviderType.UNKNOWN: {\n      yield (provider as unknown) as T;\n      return void 0;\n    }\n\n    // We can not have determined if the method was a specific method type yet. If we actually hit this, then we have\n    // found a bug.\n    case ProviderType.METHOD_SYNC:\n    case ProviderType.METHOD_ASYNC:\n    case ProviderType.GENERATOR:\n    case ProviderType.GENERATOR_ASYNC:\n      console.warn(\n        \"Undefined behavior occurred while processing a provider. No values will be returned.\"\n      );\n      return void 0;\n\n    default:\n      console.warn(\n        \"The provider could not have it's type properly determined for iteration. Thus no values will be returned.\"\n      );\n      return void 0;\n  }\n}\n","import { DataProvider } from \"./types\";\n\nexport enum ProviderType {\n  LIST,\n  METHOD,\n  METHOD_SYNC,\n  METHOD_ASYNC,\n  GENERATOR,\n  GENERATOR_ASYNC,\n  ITERATOR,\n  ITERATOR_ASYNC,\n  OBJECT,\n  PRIMITIVE,\n  SET,\n  UNKNOWN\n}\n\n/**\n * The state stored for iterating through a provider.\n */\nexport type IterState = {\n  type: ProviderType;\n};\n\n/**\n * The data provider type after it has been exposed to the iterating concept.\n */\nexport type DataProviderInternal<T> = DataProvider<T> & {\n  __iter__: { [key: string]: IterState };\n};\n\n/**\n * Typeguard for simple iterator types\n */\nexport function isIterable<T>(val: any): val is IterableIterator<T> {\n  if (!val) return false;\n  return typeof val[Symbol.iterator] === \"function\";\n}\n\n/**\n * Typeguard for async iterator types\n */\nexport function isAsyncIterable<T>(val: any): val is AsyncIterableIterator<T> {\n  if (!val) return false;\n  return typeof val[Symbol.asyncIterator] === \"function\";\n}\n","/**\n * Wrapper in the event you don't want to write out the for await loop (this causes overhead).\n *\n * This is also available to help environments that may not be able to transpile or handle the for await syntax.\n */\nexport async function retrieve<T>(\n  values: AsyncGenerator<T, void, undefined>,\n  access: (val: T) => void\n) {\n  for await (const val of values) {\n    access(val);\n  }\n}\n"],"sourceRoot":""}